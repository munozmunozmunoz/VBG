model{
    for(i in 1:n){
	  	#Fabens mark-recapture formulation
		Lr[i]~dnorm(Lr.hat[i], tau.Lr)
		Lr.hat[i] <- Lm[m[i]] + (L.inf[m[i]]-Lm[m[i]])*(1-exp(-K[m[i]]*(dT[m[i]]/365)))
	}
	#Priors for level 1
    tau.Lr <- pow(sigma.Lr,-2)
    sigma.Lr ~ dunif(0,5)

	#Level-2 parameters
    for(j in 1:J){
		L.inf[j] <- exp(B[j,1])
		K[j] <- exp(B[j,2]) #### k modeled on log-scale
		B[j,1:2] ~ dmnorm(B.hat[j,], Tau.B[,]) #Multivariate normal dist'n;  Tau.B is a precision (tau) matrix
		B.hat[j,1] <- mu.Linf
		B.hat[j,2] <- mu.k
    }
    
    #priors for level-2 parameters
    mu.Linf ~ dnorm(0,.0001)
    mu.k ~ dnorm(0,.0001)
    
    # Get grand mean k on untransformed scale
    mu.k.raw <- exp(mu.k)
    linf.raw <- exp(mu.Linf)

    Tau.B[1:2,1:2] ~ dwish(W[,], df) # Variance-covariance matrix from precision matrix (i.e., 1/tau)
    df <- 3 # df set to 1 greater than dimension of Tau.B (i.e., the number of varying parameters + 1)
    
    Sigma.B[1:2, 1:2] <- inverse(Tau.B[,]) # Calculate variance-covariance matrix Sigma.B
    
    # Obtain sigmas from variance-covariance matrix Sigma.B
    sigma.l <- sqrt(Sigma.B[1,1])
    sigma.k <- sqrt(Sigma.B[2,2])

    #correlation 
    rho[1] <- Sigma.B[1,2]/sqrt(Sigma.B[1,1]*Sigma.B[2,2])
}